<!DOCTYPE html>
<html lang="pt-br">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Rogue-like 2D Neon ‚Äî Final</title>
<style>
  body{font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background:linear-gradient(270deg,#0d6efd,#000); background-size:400% 400%; animation:gradientBG 12s ease infinite; color:#fff; margin:0; padding:20px; min-height:100vh; display:grid; place-items:center; gap:16px;}
  @keyframes gradientBG{0%{background-position:0% 50%}50%{background-position:100% 50%}100%{background-position:0% 50%}}
  h1{margin:0;font-size:1.9rem;text-shadow:0 0 10px #0d6efd}
  .hud{display:flex;gap:12px;flex-wrap:wrap;justify-content:center;width:100%;max-width:1100px}
  .card{background:rgba(0,0,0,0.45);border:2px solid rgba(255,255,255,0.18);border-radius:12px;padding:12px;width:280px;box-shadow:0 10px 24px rgba(0,0,0,0.4)}
  .bar{height:18px;border-radius:8px;background:#222;overflow:hidden;margin:8px 0;border:1px solid rgba(255,255,255,0.12)}
  .fill{height:100%;width:100%;transition:width 250ms ease}
  .hpFill{background:#2ecc71}
  canvas{background:rgba(0,0,0,0.35);border:2px solid rgba(255,255,255,0.18);border-radius:12px;box-shadow:0 10px 24px rgba(0,0,0,0.4);touch-action:none}
  #gameOverScreen{position:fixed;inset:0;background:rgba(0,0,0,0.85);display:none;flex-direction:column;justify-content:center;align-items:center;color:#fff;z-index:60}
  #gameOverScreen h2{font-size:3rem;margin-bottom:20px;text-shadow:0 0 15px red}
  #restartBtn{padding:12px 22px;font-size:16px;border-radius:8px;border:none;background:linear-gradient(90deg,#0d6efd,#8a2be2);color:#fff;cursor:pointer}
  #upgradeScreen{position:fixed;inset:0;background:rgba(0,0,0,0.92);display:none;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:14px;padding:36px;z-index:70;align-content:center}
  .upgrade-card{background:rgba(255,255,255,0.04);border:1px solid rgba(99,163,255,0.16);border-radius:12px;padding:14px;min-height:110px;display:flex;align-items:center;justify-content:center;text-align:center;cursor:pointer;font-weight:700}
  .upgrade-card:hover{transform:translateY(-3px);border-color:rgba(13,110,253,0.6);box-shadow:0 12px 30px rgba(13,110,253,0.12)}
  #bossName{position:fixed;left:50%;top:12%;transform:translateX(-50%);font-size:56px;color:rgba(255,80,80,0.95);font-weight:900;text-shadow:0 0 50px rgba(255,80,80,0.25);pointer-events:none;z-index:80;display:none}
  #log{width:100%;max-width:1100px;text-align:left;background:rgba(0,0,0,0.4);padding:12px;border-radius:12px;font-size:13px;max-height:220px;overflow:auto}
  .hint{font-size:13px;color:#cfe1ff;margin-top:8px}
</style>
</head>
<body>
  <h1>Rogue-like 2D Neon ‚Äî Vers√£o Final</h1>

  <div class="hud">
    <div class="card">
      <h3>Her√≥i</h3>
      <div class="bar"><div id="hpBar" class="fill hpFill"></div></div>
      <div>HP: <span id="hpText">100</span></div>
      <div>Atk: <span id="atkText">10</span> | Vel: <span id="spdText">2.0</span></div>
      <div class="hint">T: Toggle auto-shoot ‚Ä¢ Q: Cura ativa (se dispon√≠vel)</div>
    </div>
    <div class="card">
      <h3>Rodada / Wave</h3>
      <div>Rodada: <span id="roundText">1</span></div>
      <div>Inimigos vivos: <span id="enemyCountText">0</span></div>
      <div>Inimigos nesta rodada: <span id="enemiesToSpawnText">4</span></div>
    </div>
  </div>

  <canvas id="game" width="1100" height="600"></canvas>

  <div id="bossName"></div>
  <div id="gameOverScreen"><h2>üíÄ Game Over üíÄ</h2><button id="restartBtn">Reiniciar</button></div>
  <div id="upgradeScreen"></div>
  <div id="log"></div>

<script>
/* ---------- Estado e constantes ---------- */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const hpBar = document.getElementById('hpBar'), hpText = document.getElementById('hpText');
const atkText = document.getElementById('atkText'), spdText = document.getElementById('spdText');
const roundText = document.getElementById('roundText'), enemyCountText = document.getElementById('enemyCountText'), enemiesToSpawnText = document.getElementById('enemiesToSpawnText');
const gameOverScreen = document.getElementById('gameOverScreen'), restartBtn = document.getElementById('restartBtn');
const upgradeScreen = document.getElementById('upgradeScreen'), logEl = document.getElementById('log');
const bossNameEl = document.getElementById('bossName');

let hero = { x: canvas.width/2, y: canvas.height-100, r:16, hp:100, maxHP:100, speed:2.0, atk:10, bullets:[], fireRate:380, lastShot:0 };
let keys = {}, mouse = { x: canvas.width/2, y: canvas.height/2, pressed:false };
let enemies = [], enemyBullets = [], allies = [];
let lastSpawn = 0, spawnInterval = 1000;
let round = 1;
let enemiesToSpawn = 4;
let spawned = 0;
let killed = 0;
let waveActive = true;
let gameOver = false;
let paused = false;

// Upgrades flags
let hasTripleShot = false;
let hasPiercing = false;
let poisonEnabled = false;
let bleedEnabled = false;
let explosionOnDeath = false;
let hasAlly = false;
let lifeStealPercent = 0;
let hasHomingShot = false;
let alliesPerRound = 0;

// Healing globals
let ON_KILL_HEAL = 0;
let regenHP = 0;
let ACTIVE_HEAL_AMOUNT = 0;
let ACTIVE_HEAL_COOLDOWN = 10000;
let lastActiveHeal = 0;

// Auto-shoot toggle
let autoShoot = false;

// Explosion / DOT constants
const POISON_TICK = 3, POISON_DURATION = 5000, POISON_INTERVAL = 1000;
const BLEED_TICK = 6, BLEED_DURATION = 3000, BLEED_INTERVAL = 750;

// Boss names
const BOSS_NAMES = ["Ambatukam","Bus","Yes King","Bussin"];
let bossActive = false;
let currentBoss = null;

/* ---------- Utilit√°rios ---------- */
function log(msg){ const p=document.createElement('p'); p.textContent=msg; logEl.appendChild(p); logEl.scrollTop = logEl.scrollHeight; }
function clamp(v,min,max){return Math.max(min,Math.min(max,v));}
function updateHUD(){
  hpText.textContent = Math.round(hero.hp);
  hpBar.style.width = (hero.hp/hero.maxHP*100)+'%';
  atkText.textContent = hero.atk;
  spdText.textContent = hero.speed.toFixed(1);
  roundText.textContent = round;
  enemyCountText.textContent = enemies.length;
  enemiesToSpawnText.textContent = enemiesToSpawn;
}

/* ---------- Input ---------- */
window.addEventListener('keydown', e => {
  const k = e.key.toLowerCase();
  keys[k] = true;
  if (k === 't') {
    autoShoot = !autoShoot;
    log(autoShoot ? 'üî´ Disparo autom√°tico ativado' : 'üõë Disparo autom√°tico desativado');
  }
  if (k === 'q' && ACTIVE_HEAL_AMOUNT > 0 && !gameOver) {
    const now = performance.now();
    if (now - lastActiveHeal >= ACTIVE_HEAL_COOLDOWN){
      hero.hp = Math.min(hero.maxHP, hero.hp + ACTIVE_HEAL_AMOUNT);
      lastActiveHeal = now;
      log(`‚ú® Cura ativa: +${ACTIVE_HEAL_AMOUNT} HP`);
    } else {
      const left = Math.ceil((ACTIVE_HEAL_COOLDOWN - (now - lastActiveHeal))/1000);
      log(`Cura ativa dispon√≠vel em ${left}s`);
    }
  }
});
window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

canvas.addEventListener('mousemove', e => { const rect = canvas.getBoundingClientRect(); mouse.x = e.clientX - rect.left; mouse.y = e.clientY - rect.top; });
canvas.addEventListener('mousedown', () => { mouse.pressed = true; });
canvas.addEventListener('mouseup', () => { mouse.pressed = false; });

restartBtn.addEventListener('click', restartGame);

/* ---------- Tiro do her√≥i (com homing, triple, piercing) ---------- */
function spawnHeroBullet(angle){
  const speed = 4.0;
  const pierce = hasPiercing ? 2 : 0;
  const makeBullet = (a) => ({ x: hero.x, y: hero.y, vx: Math.cos(a)*speed, vy: Math.sin(a)*speed, r:4, dmg: hero.atk, pierce, homing: hasHomingShot });
  if (hasTripleShot){
    const spread = 0.28;
    [angle, angle - spread, angle + spread].forEach(a => hero.bullets.push(makeBullet(a)));
  } else {
    hero.bullets.push(makeBullet(angle));
  }
}

function tryShoot(ts){
  if (paused || gameOver) return;
  if (!mouse.pressed && !autoShoot) return;
  if (ts - hero.lastShot < hero.fireRate) return;
  const angle = Math.atan2(mouse.y - hero.y, mouse.x - hero.x);
  spawnHeroBullet(angle);
  hero.lastShot = ts;
}

/* ---------- Aliados ---------- */
function spawnAlly(){
  allies.push({ x: hero.x + 30, y: hero.y + 30, r:10, lastShot:0, fireRate:650, dmg: Math.max(3, Math.floor(hero.atk*0.6)) });
  hasAlly = true;
  log('Companheiro invocado!');
}
function updateAllies(ts){
  allies.forEach(a => {
    const dx = hero.x + 30 - a.x; const dy = hero.y + 30 - a.y;
    a.x += dx * 0.08; a.y += dy * 0.08;
    if (enemies.length === 0) return;
    let nearest = null, nd = Infinity;
    enemies.forEach(e => { const d = Math.hypot(e.x - a.x, e.y - a.y); if (d < nd){ nd = d; nearest = e; }});
    if (!nearest) return;
    if (ts - a.lastShot >= a.fireRate){
      const angle = Math.atan2(nearest.y - a.y, nearest.x - a.x);
      const speed = 4.0;
      enemyBullets.push({ x:a.x, y:a.y, vx:Math.cos(angle)*speed, vy:Math.sin(angle)*speed, r:3, dmg:a.dmg, friendly:true });
      a.lastShot = ts;
    }
  });
}

/* ---------- Inimigos e chefes ---------- */
function spawnEnemy(isBoss=false){
  const x = Math.random()*(canvas.width-160)+80;
  if (isBoss){
    const name = BOSS_NAMES[Math.floor(Math.random()*BOSS_NAMES.length)];
    currentBoss = {
      boss:true, name,
      x, y:-80, r:40,
      hp: 500 + round*80,
      maxHP: 500 + round*80,
      speed: 0.6 + round*0.02,
      lastShot:0, fireRate: Math.max(600, 1200 - Math.min(600, round*10)), dmg: 22 + Math.floor(round*3)
    };
    enemies.push(currentBoss);
    bossActive = true;
    bossNameEl.textContent = currentBoss.name;
    bossNameEl.style.display = 'block';
    setTimeout(()=>{ bossNameEl.style.display = 'none'; }, 3000);
    log(`üõ°Ô∏è Chefe ${currentBoss.name} apareceu!`);
    spawned++;
    return;
  }
  enemies.push({
    x, y:-20, r:14,
    hp: 40 + Math.floor(round*3),
    maxHP: 40 + Math.floor(round*3),
    speed: 0.9 + round*0.04,
    lastShot:0,
    fireRate: 1600 + Math.floor(Math.random()*700),
    poison: null,
    bleed: null
  });
  spawned++;
}

function enemyTryShoot(e, ts){
  if (paused) return;
  if (ts - e.lastShot < e.fireRate) return;
  const angle = Math.atan2(hero.y - e.y, hero.x - e.x);
  const speed = e.boss ? 3.2 : 2.4;
  enemyBullets.push({ x:e.x, y:e.y, vx:Math.cos(angle)*speed, vy:Math.sin(angle)*speed, r:4, dmg: e.boss ? e.dmg : (8 + Math.floor(round*0.6)) });
  e.lastShot = ts;
}

/* ---------- DOT (veneno, sangramento) ---------- */
function applyPoisonToEnemy(e){ e.poison = { remaining: POISON_DURATION, nextTick: performance.now() + POISON_INTERVAL }; }
function applyBleedToEnemy(e){ e.bleed = { remaining: BLEED_DURATION, nextTick: performance.now() + BLEED_INTERVAL }; }
function processDot(e, ts){
  if (e.poison){
    if (ts >= e.poison.nextTick){ e.hp -= POISON_TICK; e.poison.remaining -= POISON_INTERVAL; e.poison.nextTick += POISON_INTERVAL; }
    if (e.poison.remaining <= 0) e.poison = null;
  }
  if (e.bleed){
    if (ts >= e.bleed.nextTick){ e.hp -= BLEED_TICK; e.bleed.remaining -= BLEED_INTERVAL; e.bleed.nextTick += BLEED_INTERVAL; }
    if (e.bleed.remaining <= 0) e.bleed = null;
  }
}

/* ---------- Explos√£o verde (amiga) ---------- */
function explodeEnemy(e){
  const count = 5;
  for (let i=0;i<count;i++){
    const a = (i / count) * Math.PI*2;
    const speed = 3.2;
    enemyBullets.push({ x:e.x, y:e.y, vx:Math.cos(a)*speed, vy:Math.sin(a)*speed, r:4, dmg: Math.max(6, Math.floor(hero.atk*0.8)), friendly:true, explosion:true });
  }
}

/* ---------- Life steal ---------- */
function applyLifeSteal(amount){
  if (lifeStealPercent <= 0) return;
  const heal = Math.round(amount * lifeStealPercent);
  if (heal <= 0) return;
  hero.hp = Math.min(hero.maxHP, hero.hp + heal);
  log(`‚ù§Ô∏è Roubo de vida: +${heal} HP`);
}

/* ---------- Atualiza√ß√£o do jogo ---------- */
function update(ts, dt){
  if (gameOver || paused) return;

  // regen passiva
  if (regenHP > 0) hero.hp = Math.min(hero.maxHP, hero.hp + regenHP * (dt/1000));

  // movimento
  let dx=0, dy=0;
  if (keys['w']) dy -= 1;
  if (keys['s']) dy += 1;
  if (keys['a']) dx -= 1;
  if (keys['d']) dx += 1;
  const len = Math.hypot(dx,dy) || 1;
  hero.x = clamp(hero.x + (dx/len) * hero.speed * 3, 10, canvas.width-10);
  hero.y = clamp(hero.y + (dy/len) * hero.speed * 3, 10, canvas.height-10);

  tryShoot(ts);
  if (hasAlly) updateAllies(ts);

  // spawn at√© completar rodada (boss spawn no in√≠cio quando round %10===0)
  if (waveActive && spawned < enemiesToSpawn && ts - lastSpawn > spawnInterval){
    if (round % 10 === 0 && spawned === 0){
      spawnEnemy(true);
    } else {
      spawnEnemy(false);
    }
    lastSpawn = ts;
  }

  // atualizar inimigos
  enemies.forEach(e => {
    const ddx = hero.x - e.x, ddy = hero.y - e.y;
    const dist = Math.hypot(ddx,ddy) || 1;
    const vx = (ddx/dist) * e.speed * (e.boss ? 1.4 : 2);
    const vy = (ddy/dist) * e.speed * (e.boss ? 1.4 : 2);
    e.x += vx; e.y += vy;
    processDot(e, ts);
    enemyTryShoot(e, ts);
  });

  // atualizar balas (her√≥i)
  hero.bullets.forEach(b => {
    // homing bullets adjust velocity toward nearest enemy
    if (b.homing && enemies.length > 0){
      let target = null, md = Infinity;
      enemies.forEach(e => { const d = Math.hypot(e.x - b.x, e.y - b.y); if (d < md){ md = d; target = e; }});
      if (target){
        const dx = target.x - b.x, dy = target.y - b.y;
        const dist = Math.hypot(dx, dy) || 1;
        const speed = Math.hypot(b.vx, b.vy) || 4.0;
        b.vx = (dx / dist) * speed;
        b.vy = (dy / dist) * speed;
      }
    }
    b.x += b.vx; b.y += b.vy;
  });

  // atualizar balas inimigas / amig√°veis
  enemyBullets.forEach(b => { b.x += b.vx; b.y += b.vy; });

  // colis√µes: balas do her√≥i em inimigos
  hero.bullets.forEach(b => {
    enemies.forEach(e => {
      if (e._dead) return;
      if (Math.hypot(b.x - e.x, b.y - e.y) < b.r + e.r){
        const prevHP = e.hp;
        e.hp -= b.dmg;
        const damageDealt = Math.min(b.dmg, prevHP);
        if (lifeStealPercent > 0 && damageDealt > 0) applyLifeSteal(damageDealt);
        if (poisonEnabled && Math.random() < 0.35) applyPoisonToEnemy(e);
        if (bleedEnabled && Math.random() < 0.35) applyBleedToEnemy(e);
        if (b.pierce && b.pierce > 0) b.pierce--; else b._remove = true;
        if (e.hp <= 0){ e._dead = true; killed++; if (explosionOnDeath) explodeEnemy(e); if (ON_KILL_HEAL>0){ hero.hp = Math.min(hero.maxHP, hero.hp + ON_KILL_HEAL); log(`+${ON_KILL_HEAL} HP ao matar`); } }
      }
    });
  });

  // colis√µes: balas hostis vs her√≥i
  enemyBullets.forEach(b => {
    if (b.friendly) return;
    if (Math.hypot(b.x - hero.x, b.y - hero.y) < b.r + hero.r){
      hero.hp = Math.max(0, hero.hp - b.dmg);
      b._remove = true;
      if (hero.hp <= 0) triggerGameOver();
    }
  });

  // colis√µes: balas amig√°veis (aliados e explos√µes) vs inimigos
  enemyBullets.forEach(b => {
    if (!b.friendly) return;
    enemies.forEach(e => {
      if (e._dead) return;
      if (Math.hypot(b.x - e.x, b.y - e.y) < b.r + e.r){
        const prevHP = e.hp;
        e.hp -= b.dmg;
        const damageDealt = Math.min(b.dmg, prevHP);
        if (lifeStealPercent > 0 && damageDealt > 0) applyLifeSteal(damageDealt);
        b._remove = true;
        if (e.hp <= 0){ e._dead = true; killed++; if (explosionOnDeath) explodeEnemy(e); if (ON_KILL_HEAL>0){ hero.hp = Math.min(hero.maxHP, hero.hp + ON_KILL_HEAL); log(`+${ON_KILL_HEAL} HP ao matar`); } }
      }
    });
  });

  // limpeza de balas
  hero.bullets = hero.bullets.filter(b => !b._remove && b.x > -80 && b.x < canvas.width+80 && b.y > -80 && b.y < canvas.height+80);
  enemyBullets = enemyBullets.filter(b => !b._remove && b.x > -80 && b.x < canvas.width+80 && b.y > -80 && b.y < canvas.height+80);

  // remover inimigos mortos / fora de tela
  enemies = enemies.filter(e => {
    if (e._dead){
      if (e.boss){ bossActive = false; currentBoss = null; bossNameEl.style.display = 'none'; log('üèÜ Chefe derrotado!'); }
      return false;
    }
    return e.y < canvas.height + 140;
  });

  // fim de wave: todos os inimigos dessa rodada nasceram e morreram
  if (spawned >= enemiesToSpawn && enemies.length === 0 && killed >= enemiesToSpawn){
    waveActive = false;
    handleRoundEnd();
  }

  updateHUD();
}

/* ---------- Desenho ---------- */
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // grade sutil
  ctx.save(); ctx.strokeStyle = 'rgba(255,255,255,0.04)';
  for (let x=0;x<canvas.width;x+=40){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke(); }
  for (let y=0;y<canvas.height;y+=40){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke(); }
  ctx.restore();

  // her√≥i
  ctx.save(); ctx.fillStyle = '#cfe1ff'; ctx.beginPath(); ctx.arc(hero.x, hero.y, hero.r, 0, Math.PI*2); ctx.fill();
  ctx.strokeStyle = 'rgba(13,110,253,0.9)'; ctx.beginPath(); ctx.moveTo(hero.x, hero.y); ctx.lineTo(mouse.x, mouse.y); ctx.stroke(); ctx.restore();

  // aliados
  allies.forEach(a => { ctx.save(); ctx.fillStyle = '#7fe0ff'; ctx.beginPath(); ctx.arc(a.x, a.y, a.r, 0, Math.PI*2); ctx.fill(); ctx.restore(); });

  // inimigos
  enemies.forEach(e => {
    ctx.save();
    ctx.fillStyle = e.boss ? '#ffb277' : '#e74c3c';
    ctx.beginPath(); ctx.arc(e.x, e.y, e.r, 0, Math.PI*2); ctx.fill();
    const w = e.boss ? 180 : 30, h = e.boss ? 12 : 5;
    const pct = Math.max(0, e.hp) / e.maxHP;
    ctx.fillStyle = '#111'; ctx.fillRect(e.x - w/2, e.y - e.r - (h+8), w, h);
    ctx.fillStyle = '#2ecc71'; ctx.fillRect(e.x - w/2, e.y - e.r - (h+8), w * pct, h);
    if (e.poison) { ctx.fillStyle = 'rgba(120,200,80,0.9)'; ctx.fillRect(e.x - w/2, e.y - e.r - (h+14), 8, 6); }
    if (e.bleed)  { ctx.fillStyle = 'rgba(200,60,60,0.95)'; ctx.fillRect(e.x - w/2 + 12, e.y - e.r - (h+14), 8, 6); }
    if (e.boss){ ctx.fillStyle = 'rgba(255,255,255,0.95)'; ctx.font='14px bold sans-serif'; ctx.textAlign='center'; ctx.fillText(e.name, e.x, e.y - e.r - 28); }
    ctx.restore();
  });

  // balas do her√≥i (roxo)
  ctx.save(); ctx.fillStyle = '#8a2be2'; hero.bullets.forEach(b => { ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill(); }); ctx.restore();

  // balas inimigas e amig√°veis (vermelho hostil, ciano aliado, verde explos√£o)
  enemyBullets.forEach(b => {
    ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2);
    if (b.friendly && b.explosion) ctx.fillStyle = '#65ff8a';
    else if (b.friendly) ctx.fillStyle = '#7fe0ff';
    else ctx.fillStyle = '#ff5555';
    ctx.fill();
  });
}

/* ---------- Upgrades & fluxo de rodada ---------- */
const ALL_UPGRADES = [
  { name: "Tiro Triplo (spread)", apply: () => { hasTripleShot = true; log('Upgrade: Tiro Triplo ativo'); } },
  { name: "Tiro Perfurante (piercing)", apply: () => { hasPiercing = true; log('Upgrade: Tiro Perfurante ativo'); } },
  { name: "Venenoso (aplica veneno)", apply: () => { poisonEnabled = true; log('Upgrade: Veneno habilitado'); } },
  { name: "Sangramento (aplica bleed)", apply: () => { bleedEnabled = true; log('Upgrade: Sangramento habilitado'); } },
  { name: "Explos√£o (inimigo explode em 5 tiros verdes)", apply: () => { explosionOnDeath = true; log('Upgrade: Explos√£o ao morrer ativada'); } },
  { name: "Companheiro (invoca aliado)", apply: () => { if (!hasAlly) spawnAlly(); } },
  { name: "Roubo de Vida 15%", apply: () => { lifeStealPercent = Math.max(lifeStealPercent, 0.15); log('Upgrade: Roubo de Vida 15%'); } },
  { name: "Cura ao matar +20 HP", apply: () => { ON_KILL_HEAL = Math.max(ON_KILL_HEAL, 20); log('Upgrade: Cura ao matar +20 HP'); } },
  { name: "Regenera√ß√£o +1 HP/s", apply: () => { regenHP = Math.max(regenHP, (regenHP || 0) + 1); log('Upgrade: Regenera√ß√£o +1 HP/s'); } },
  { name: "Cura ativa +30 (Q)", apply: () => { ACTIVE_HEAL_AMOUNT = Math.max(ACTIVE_HEAL_AMOUNT, 30); ACTIVE_HEAL_COOLDOWN = Math.min(ACTIVE_HEAL_COOLDOWN, 6000); log('Upgrade: Cura ativa +30'); } },
  { name: "For√ßa +5 Atk", apply: () => { hero.atk += 5; log('Upgrade: +5 ATK'); } },
  { name: "Velocidade +0.5", apply: () => { hero.speed += 0.5; log('Upgrade: +0.5 Vel'); } },
  { name: "Tiro Perseguidor (homing)", apply: () => { hasHomingShot = true; log('Upgrade: Tiro Perseguidor ativado'); } },
  { name: "Aliado por Rodada (+1)", apply: () => { alliesPerRound += 1; log('Upgrade: +1 aliado por rodada'); } }
];

function showUpgrades(onChosen){
  paused = true;
  upgradeScreen.innerHTML = '';
  upgradeScreen.style.display = 'grid';
  for (let i=0;i<5;i++){
    const upg = ALL_UPGRADES[Math.floor(Math.random()*ALL_UPGRADES.length)];
    const d = document.createElement('div');
    d.className = 'upgrade-card';
    d.textContent = upg.name;
    d.onclick = () => {
      upg.apply();
      upgradeScreen.style.display = 'none';
      paused = false;
      if (typeof onChosen === 'function') onChosen();
    };
    upgradeScreen.appendChild(d);
  }
}

function handleRoundEnd(){
  // ao final da rodada, incrementar, somar +10 inimigos e invocar aliados por rodada
  round++;
  enemiesToSpawn += 10;
  spawned = 0; killed = 0;
  waveActive = true; lastSpawn = 0;
  // invoca aliados por rodada
  for (let i=0;i<alliesPerRound;i++){ spawnAlly(); }
  // upgrades a cada 2 rodadas
  if (round % 2 === 0) showUpgrades(startRound); else startRound();
  updateHUD();
}

function startRound(){
  waveActive = true;
  spawnInterval = Math.max(300, spawnInterval - 20);
  log(`‚û°Ô∏è Rodada ${round} iniciada ‚Äî inimigos: ${enemiesToSpawn}`);
}

/* ---------- Game over & reiniciar ---------- */
function triggerGameOver(){
  gameOver = true;
  gameOverScreen.style.display = 'flex';
  log('üíÄ Voc√™ foi derrotado!');
}
function restartGame(){
  hero = { x: canvas.width/2, y: canvas.height-100, r:16, hp:100, maxHP:100, speed:2.0, atk:10, bullets:[], fireRate:380, lastShot:0 };
  keys = {}; mouse = { x: canvas.width/2, y: canvas.height/2, pressed:false };
  enemies = []; enemyBullets = []; allies = [];
  lastSpawn = 0; spawnInterval = 1000;
  round = 1; enemiesToSpawn = 4; spawned = 0; killed = 0; waveActive = true;
  gameOver = false; paused = false; bossActive = false; currentBoss = null; bossNameEl.style.display='none';
  hasTripleShot = false; hasPiercing = false; poisonEnabled=false; bleedEnabled=false; explosionOnDeath=false; hasAlly=false;
  lifeStealPercent = 0; hasHomingShot=false; alliesPerRound=0;
  ON_KILL_HEAL = 0; regenHP = 0; ACTIVE_HEAL_AMOUNT = 0; ACTIVE_HEAL_COOLDOWN = 10000; lastActiveHeal = 0;
  upgradeScreen.style.display = 'none'; gameOverScreen.style.display = 'none';
  logEl.innerHTML = ''; log('üîÑ Jogo reiniciado');
  updateHUD();
}

/* ---------- Loop principal ---------- */
let lastTime = performance.now();
function loop(ts){
  const dt = ts - lastTime; lastTime = ts;
  update(ts, dt);
  draw();
  requestAnimationFrame(loop);
}

/* ---------- Iniciar ---------- */
updateHUD();
log('üéÆ Jogo iniciado. Rodada 1 com 4 inimigos. A cada rodada +10 inimigos. Chefes a cada 10 rodadas. Upgrades a cada 2 rodadas (pausa).');
log('Dicas: T para auto-shoot, Q para cura ativa quando obtida.');
requestAnimationFrame(loop);
</script>
</body>
</html>
